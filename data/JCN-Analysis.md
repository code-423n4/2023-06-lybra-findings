*This analysis report is meant to accompany my Gas Optimizations Report submission. All insights will be given through the perspective of optimizing the codebase.*

My main focus when reviewing this codebase was optimizing storage layout and reducing excessive storage operations.

Some immediate impressions about the gas usage of this protocol: Substantial gas savings are being left on the table in regards to storage operations. A fair amount of state variables use `uint256` when they have enforced maximum upper bounds. These upper bounds allow the variables to be of a lower `uint` type. This would ultimately result in those state variables being able to be packed with other variables. Packing state variables will yield various types of gas savings: A `Gsset (20000 gas)` will be saved during construction and a `Gcoldsload (2100 gas)` will be saved when the packed variables are accessed in the same function call. These savings come from the fact that writing to `unoccupied` storage slots are more expensive than writing to `occupied` storage slots (i.e. Writing to a slot that has no value (zero) is much more expensive than writing to a slot that is non-zero). In addition, if multiple packed variables are accessed in the same function call, the storage slot they occupy will become `warm` after the first access, resulting in cheaper accesses thereafter. This observation was shown to be a pattern throughout various contracts, and thus I prioritized these types of findings in my report. 

Another aspect of the codebase that was more gas intensive was the use of `public` and `internal` funcitons within state-mutating functions. Specifically, `public`/`internal` functions which accessed storage slots that were previous accessed in the parent function. In addition, some `public`/`internal` functions also performed redundant external calls. It is less obvious to notice storage reads as they occur in invoked functions, rather than the parent function. Although separating the functions is good practice and keeps the code organized, it can be easy to let redundant storage reads go unnoticed. This unfortunately is the case with certain contracts in this codebase. Some functions perform numerous calls to `public`/`internal` functions that ultimately re-access the same storage slots that were previous accessed. There is one piece of code I would like to highlight, that was particularily expensive. The `updateReward` modifier in `EUSDMiningIncentives.sol` and `stakerewardV2pool.sol` performed various storage reads and writes as well as called `public` functions which did their own set of storage reads (many of which are redundant). The `Refactor functions to avoid excessive storage reads` finding in my report is a less obvious optimization, but one that I believe this protocol can benefit from, especially when examining the logic flow of any function that uses the `updateReward` modifier. 

However, it is important to note that while refactoring is needed for these optimizations, maintaining code readbility is something to consider. I would highly suggest to not implement the changes in my report without the proper testing. Refactoring functions after the fact can be confusing as you will need to follow the logic flow closely in order to pinpoint and optimize the redundant storage reads that are nested within function calls. I would suggest prioritizing testing the optimizations that deal with storage layout as they will yield the most apparent and significant gas savings. 

Please note that `bot-like` findings have been purposefully excluded from my report in an attempt to bring more value to the sponsors in addition to the findings from the bot race.

### Time spent:
15 hours